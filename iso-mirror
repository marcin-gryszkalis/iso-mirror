#!/usr/bin/perl
# https://github.com/marcin-gryszkalis/iso-mirror
my $VERSION  = '0.1';

use warnings;
use strict;
use feature qw/state signatures say multidimensional/;
use utf8;
use open qw(:std :encoding(UTF-8));

use File::Slurp;
use Data::Dumper;
use FindBin qw($Bin);
use JSON qw(decode_json);
use YAML ();
use Config::INI::Reader;
use Version::Compare;
use Pod::Usage;
use Getopt::Auto;
use Net::Curl::Easy qw(:constants);
use Net::Curl::Form qw(:constants);
use Term::ProgressBar;
use Number::Bytes::Human qw(format_bytes);
use List::Util qw/min max first sum sum0 product all any uniq head tail reduce pairs zip mesh/;
use List::MoreUtils qw/firstidx frequency mode slide minmax/;
# use POSIX qw/ceil floor/;

our %options;

sub usage {
    pod2usage( -verbose => 2 );
    exit 0;
}

sub write_file_ok
{
    write_file($_[0], {binmode => ':utf8'}, $_[1]);
}

my $logfh = *STDOUT;
sub LOG
{
    my $d = POSIX::strftime("%F %T", localtime);
    my $m = join(" ",@_);
    $m =~ s/[\r\n]/ /g;
    print($logfh "$d $m\n");
}

sub LOGraw
{
    my $m = join(" ",@_);
    print($logfh "$m\n");
}

sub ERR
{
    LOG "ERROR: ".shift;
    exit 1;
}

sub WARN
{
    LOG "WARNING: ".shift;
}


my $curl = Net::Curl::Easy->new();
$curl->setopt(CURLOPT_FOLLOWLOCATION, 1);
$curl->setopt(CURLOPT_AUTOREFERER, 1);
$curl->setopt(CURLOPT_MAXREDIRS, 64);

$curl->setopt(CURLOPT_FORBID_REUSE, 0);

$curl->setopt( CURLOPT_COOKIEFILE, "");
# $curl->setopt(CURLOPT_SSL_VERIFYPEER, 0);
# $curl->setopt(CURLOPT_SSL_VERIFYHOST, 0);
$curl->setopt(CURLOPT_FAILONERROR, 1);

$curl->setopt(CURLOPT_HTTPGET, 1); #
# $curl->setopt(CURLOPT_POST, 0);
# $curl->setopt(CURLOPT_NOBODY, 0); # HEAD

    # if (defined $cfg{proxy})
    # {
    #     $curl->setopt(CURLOPT_PROXY, $cfg{proxy});
    #     if ($cfg{proxy} =~ m{^socks})
    #     {
    #         $curl->setopt(CURLOPT_PROXYTYPE, CURLPROXY_SOCKS5);
    #     }
    #     elsif ($cfg{proxy} =~ m{^https})
    #     {
    #         $curl->setopt(CURLOPT_PROXYTYPE, CURLPROXY_HTTPS);
    #     }
    #     else
    #     {
    #         $curl->setopt(CURLOPT_PROXYTYPE, CURLPROXY_HTTP);
    #         # $curl->setopt(CURLOPT_PROXYTYPE, CURLPROXY_HTTP_1_0);
    #     }
    #     # curl->setopt(curl, CURLOPT_HTTPPROXYTUNNEL, 1);
    # }

    # if (defined $cfg{sourceip})
    # {
    #     $curl->setopt(CURLOPT_INTERFACE, $cfg{sourceip});
    # }

sub xget($url)
{
    my $contents;
    $curl->setopt(CURLOPT_URL, $url);
    $curl->setopt(CURLOPT_WRITEDATA, \$contents);

    eval 
    {
        $curl->perform();
    };

    return "" if ref $@ eq "Net::Curl::Easy::Code"; 
    return $contents;
}

sub xlen($url)
{
    $curl->setopt(CURLOPT_URL, $url);
    $curl->setopt(CURLOPT_NOBODY, 1); # HEAD
    eval
    {
        $curl->perform();
    };

    $curl->setopt(CURLOPT_NOBODY, 0);
    return 0 if ref $@ eq "Net::Curl::Easy::Code"; 
    my $len = $curl->getinfo(CURLINFO_CONTENT_LENGTH_DOWNLOAD);
    return $len;
}

my $progressbar = undef;
sub curl_progress 
{
    my ($easy, $dltotal, $dlnow, $ultotal, $ulnow, $uservar) = @_;

    my $percent = $dltotal > 0 ? int($dlnow * 100 / $dltotal) : 0;
    $progressbar->update($percent); 

    return 0;
}

sub xdownload($url, $dest, $label)
{
    $curl->setopt(CURLOPT_URL, $url);
    my $f = undef;
    open($f, ">", $dest) or ERR "Cannot save to $dest -- $!";
    $curl->setopt(CURLOPT_WRITEDATA, \$f);

    $curl->setopt(CURLOPT_NOPROGRESS, 0);
    $curl->setopt(CURLOPT_XFERINFOFUNCTION, \&curl_progress);

    $progressbar = Term::ProgressBar->new({ count => 100, name => $label, ETA => 'linear', term_width => 80 });

    eval
    {
        $curl->perform();
    };


    if (ref $@ eq "Net::Curl::Easy::Code")
    {
        WARN "Problem downloading $url: $@";
        close $f;
        unlink $dest;
    } 
    else
    {
        ERR $@ if defined $@;
    }   

    LOGraw ""; # break line after progress bar
    
}

sub isyes($s)
{
    return $s =~ /yes/i;
}

LOG "iso-mirror $VERSION";
LOG "Loading configs";
my $iso = YAML::LoadFile("$Bin/iso.yaml");
my $cfg = YAML::LoadFile("$Bin/config.yaml");
$cfg = $cfg->{Options};

my %rlengths; # url -> content-length
my %todownload; # url -> dest file

for my $system (@{$cfg->{"system"}})
{
    LOG "System: $system";
    unless (exists $iso->{Systems}->{$system})
    {
        ERR "cannot find $system in iso.yaml configuration";
    }

    my $s = $iso->{Systems}->{$system};
    my $h = xget($s->{"versions-url"});
    if ($h eq '')
    {
        WARN "cannot get $s->{'versions-url'}";
        next;
    }

    my @vers = ($h =~ /$s->{"versions-rule"}/g);
    if (scalar @vers == 0)
    {
        WARN "Cannot find any valid version";
    }

    my @uv = ();
    for my $v (uniq @vers)
    {
        LOG "Checking $system version: $v";
        if(exists $s->{"min-version"} && &Version::Compare::version_compare($v,$s->{"min-version"}) == -1)
        {
            next;
        }
        push(@uv, $v);
    }

    for my $v (@uv)
    {
        for my $arc (@{$cfg->{architecture}})
        {
            if (exists $s->{"architecture-map"})
            {
                for my $am ($s->{"architecture-map"})
                {
                    my ($a,$b) = split/\s+/, $am;
                    $arc = $b if $arc eq $a;
                }
            }

            LOG "Verify $system version: $v architecture: $arc";
            my @urls = ();
            if (exists $s->{"download-url"})
            {
                my $h = xget($s->{"download-url"});
                my @du = ($h =~ /$s->{"download-rule"}/g);
                push(@urls, uniq @du);
            }

            if (exists $s->{"download"})
            {
                if (ref $s->{"download"} eq 'ARRAY')
                {
                    push(@urls, @{$s->{"download"}});
                }
                else
                {
                    push(@urls, $s->{"download"});
                }
            }

            @urls = uniq sort @urls;
            for my $u (@urls)
            {
                $u =~ s/{version}/$v/g;
                $u =~ s/{architecture}/$arc/g;
            }

            for my $u (@urls)
            {
                LOG "Process URL: $u";

                my $fn = $u;
                $fn =~ s{.*/}{};

                mkdir $cfg->{"destination-dir"} unless -d $cfg->{"destination-dir"};
                my $ddir = $cfg->{"destination-dir"}.(isyes($cfg->{"dir-per-system"}) ? "/$system/" : "/");
                $ddir =~ s{/+}{/}g;
                mkdir $ddir unless -f $ddir;
                my $dest = "$ddir/$fn";
                $dest =~ s{/+}{/}g;

                my $rl = xlen($u);
                if ($rl > 0)
                {
                    $rlengths{$u} = $rl;
                }

                if (-f $dest)
                {
                    my $ll = -s $dest;
                    if ($rl > 0 && $rl == $ll) # exists and same length
                    {
                        LOG "Skip $u";
                        next;
                    }
                
                    unlink $dest;
                }

                LOG "Download $u (".format_bytes($rl).") -> $dest";
                $todownload{$u} = $dest;
                xdownload($u, $dest, "$system $v $arc");
            }

        }
    }

    exit
}

exit;

# print Dumper $iso;


  # curl -o "$file" -z "$file" "$uri"


my $count;
sub add { $count += shift @ARGV; }
$count += $options{'--inc'};
print "Count: $count\n";

# eval {
#   $result = (Term::ReadKey::GetTerminalSize($fh))[0];
#   $result-- if ($^O eq "MSWin32" or $^O eq "cygwin");
# }; if ( $@ ) {
#   warn "error from Term::ReadKey::GetTerminalSize(): $@";
# }


=pod

=head1 NAME

iso-mirror -- mirror set of .iso files for use in multiboot environment like I<Ventoy>

=head1 SYNOPSIS

iso-mirror [B<--config>=I<file>] [B<--dry-run>] [B<--version>]

iso-mirror B<--help>

=head1 DESCRIPTION

B<iso-mirror> is


=head1 OPTIONS

=over 1

=item B<-c --config>=I<file>    specify location of `config.yaml` file

=item B<-n --dry-run>        check pages and show what would be downloaded, also show what would be deleted when `delete-obsolete` configuration option is enabled

=back

The integer argument is not checked.

=head1 EXIT STATUS

In case of errors downloading something B<iso-mirror> will exit with status 1.
In case of fatal errors (like syntax error in configuration file) exit code will be 255.

=head1 AUTHOR

Marcin Gryszalis <mg@fork.pl>

=head1 COPYRIGHT AND LICENSE

=head1 SEE ALSO

=cut

# pod2man -c "iso-mirror manual" -r 0.1 iso-mirror > iso-mirror.1
